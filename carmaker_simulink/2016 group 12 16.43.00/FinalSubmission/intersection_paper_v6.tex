%\documentclass[journal]{IEEEtran}
\documentclass[letterpaper,10pt,conference]{ieeeconf}

\IEEEoverridecommandlockouts                              % This command is only
                                                          % needed if you want to
                                                          % use the \thanks command
\overrideIEEEmargins
% See the \addtolength command later in the file to balance the column lengths
% on the last page of the document

\usepackage{amsmath,amssymb}
\usepackage{graphicx}                    % For pdf, bitmapped graphics files
\usepackage[usenames,dvipsnames]{xcolor} % For font in color
\usepackage{eurosym}
\usepackage{hyperref}% For writing sybmol for euro
\usepackage{siunitx}                     % For writing SI units
%\usepackage{subfigure}                   % For subfigures
%\usepackage{multirow}                    % Span table cells on multiple rows
%\usepackage{balance}                     % For ballancing the last page

\usepackage[]{units}
\usepackage{comment}
% custom commands
\newcommand{\red}[1]{\textcolor{red}{#1}}  % we use red color for comments

%\author{Nikolce Murgovski, Gabriel Rodrigues de Campos, Jonas Sj\"oberg
%\thanks{The authors are with the Department of Signals and Systems, Chalmers University of Technology, Sweden. {\tt \{nikolce.murgovski, gabriel.campos, jonas.sjoberg\}@chalmers.se.}}%
%\thanks{G. R. Campos is also with the DEIB, Politecnico di Milano, Italy. {\tt gabriel.rodriguesdecampos@polimi.it}}%
%\thanks{The research leading to these results was supported by the grant AD14VARI02 - Progetto ERC BETTER CARS - Sottomisura B, the S2, SAFER, and by the European Commission Seventh Framework Programme under the project AdaptIVe, grant agreement number 610428.}% <-this % stops a space
%}
\author{Lea Riegger, Markus Carlander, Niklas Lidander, Nikolce Murgovski, Jonas Sj\"oberg
\thanks{This work was supported by the European Commission Seventh Framework
Program under the project AdaptIVe, grant agreement number 610428.}
\thanks{This work has been performed by the first three authors as a
  student project supervised by the last two authors, Nikolce Murgovski
  and Jonas Sj\"oberg who are with the Department of Signals and Systems, Chalmers University of Technology, Sweden. {\tt \{nikolce.murgovski, jonas.sjoberg\}@chalmers.se.}}}%
%\thanks{G. R. Campos is also with the DEIB, Politecnico di Milano, Italy. {\tt gabriel.rodriguesdecampos@polimi.it}}%
%\thanks{The research leading to these results was supported by the grant AD14VARI02 - Progetto ERC BETTER CARS - Sottomisura B, the S2, SAFER, and by the European Commission Seventh Framework Programme under the project AdaptIVe, grant agreement number 610428.}% <-this % stops a space
%}

\newlength \figwidth
\setlength \figwidth {\columnwidth}


\graphicspath{{figures/}}

\begin{document}
\title{Centralized MPC for Autonomous Intersection Crossing}

\maketitle
\thispagestyle{empty}
\pagestyle{empty}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{abstract}
This paper develops a method for a safe and autonomous intersection
crossing. A centralized system controls autonomous vehicles within a
certain surrounding of the intersection and generates optimized
trajectories for all vehicles in the area. A recently proposed design
approach, \cite{nikolce},
where this problem is expressed as a convex optimization problem using
space sampling instead of time sampling, is formulated as a MPC
problem solved by a QP algorithms so that it can be executed in real time.
The MPC controller is then integrated in CarMaker using
Matlab/Simulink so that the controller can be validated against the
advanced vehicle models and sensor models available in
CarMaker. Preliminary results of this validation are presented. Also, a
method is designed to obtain time gaps between the vehicles to prevent the
optimization problem to become infeasible when sensors give noisy measurements.
\end{abstract}

\IEEEpeerreviewmaketitle

\section{Introduction}%from the planning report, we have to change that a bit

Around the world, traffic accidents that are related to intersections occur all too often. Compiled statistic from several European Countries shows that \SI{43}{\%} of all road injury accidents can be related to intersections \cite{molinero}. Statistic conducted in the USA indicates similar numbers \cite{nhtsa}. The actual number of related traffic accidents in Sweden is slightly less in total. Of all reported accidents in the year 2014 in Sweden, \SI{24}{\%} are intersection related. Of those, \SI{91}{\%} led to severe person injuries \cite{sverige}. As the statistics show, intersections lead to high risk for accidents. Even though the most dangerous intersections are regulated by traffic lights, signs and road-markings, accidents occur still very frequently. On the contrary, improving the safety at intersection crossing by, e.g., installing traffic lights, may also come at a price in today's society since it limits the traffic flow. This causes bottlenecks in the traffic rhythm which not only wastes a lot of time for travelers but also leads to environment pollution caused by unnecessary accelerations/decelerations and engine idling operation.

Today's vehicles are trending to become more and more autonomous. Exclusive benefits as adaptive cruise control, automatic lane change maneuvers, parking assistance are available on the market today. Statistics from USA show that about \SI{96}{\%} of all intersection related accidents are attributed to drivers \cite{nhtsa}. If intersections would be controlled by an autonomous cooperative intersection algorithm that can optimize the crossing sequence for all nearby vehicles, the intersection should be made more safe since no human factor would cause accidents. The intersection should also be more efficient in both terms, time and energy consumption, since the algorithm would decide the crossing order and vehicles' speed for maximum efficiency. Aspects as minimizing deceleration, respectively acceleration, as well as reducing the total time for the intersection crossing could be taken into account for computing the optimal crossing sequence. It would also be possible to set different priority orders for different types of vehicles, for example according to their fuel consumption and performance. Emergency vehicles could be given precedence to enter the intersection on call-out.

In this paper, a Model Predictive Controller (MPC) is designed for a centralized system which takes control over autonomous vehicles within a certain surrounding of the intersection. The vehicles are assumed to drive fully autonomously. Among other recent work some have already exploited the idea of using different MPC implementations \cite{eleven}, \cite{twelve}, \cite{thirteen}, \cite{fourteen}, \cite{fifteen}, \cite{gillet}, \cite{nikolce}. In \cite{thirteen} for example, the solution is approximated by a centralized, finite time optimal control problem. In \cite{fourteen}, a decentralized approach based on sub-optimal decision-making heuristics is used.

The general optimization algorithm for intersection crossing in this
paper is based on the modeling approach of \cite{nikolce} where the
problem is formulated in space coordinates and the inverse of speed is
used as a state variable. For a given crossing sequence, the approach
allows the problem to be formulated as a convex program that optimizes
vehicles' speed and prevents collision in a smooth way. 

This paper has three main contributions. First, an MPC, based on a
point mass model, is designed
rested on the convex modeling proposed by \cite{nikolce}. The MPC,
expressed as an quadratic program, (QP),
generates optimized trajectories for all vehicles in the controlled
area, such that a cost function is minimized and the constraints are
satisfied. The vehicles may differ in speed, acceleration and braking
capabilities. 
Second, to validate the controller based on the point mass model,
the MPC is implemented in Matlab/Simulink and the simulation
tool CarMaker, which provides advanced vehicle models and sensor
models. Preliminary results with this simulation environment are
presented where also the computational aspects of the algorithm are
illustrated. Third, when the control is based on noisy sensor signals,
it may happen that the trajectory optimization, which is repeated each
sampling instant, becomes infeasible. This is solved by introducing a penalized
time gap in the optimization criterion.
%Even though the design of the MPC controller is a highlighted area, the focus of this article is on the implementation and simulation using CarMaker.

The paper is organized as follows: Section \ref{sec:problem_formulation} gives an overview of the convex problem formulation in space coordinates. In Section \ref{sec:MPC}, an MPC is designed. Section \ref{sec:simulation} provides an MPC simulation in CarMaker running under Matlab/Simulink. Section \ref{sec:casestudy} shows a case study and investigates the controller efficiency in the simulation environment. Section \ref{sec:conclusions} closes the paper with final conclusions.

\section{Problem Formulation} \label{sec:problem_formulation}
This section presents the modeling approach proposed by \cite{nikolce} and formulates the autonomous intersection crossing as a convex optimization problem.

\subsection{Assumptions}
Considering $N_v$ autonomous vehicles in a surrounding of an intersection, each with a predefined path to follow, it is assumed that for each vehicle $i=1,...N_v$, the acceleration along its path can be varied. The vehicle dynamics in the control model are simplified to a point mass model.

The presented intersection crossing scenario is limited to one vehicle per lane which means that the scenario where vehicles are following each other on the same lane is not studied here. Nevertheless, the controller is designed in such a way that an adaptation to enable this is possible.

\subsection{Problem statement}
For a safe intersection crossing, autonomous vehicles within a certain surrounding of the intersection shall be controlled by a centralized system.
An illustration of an intersection is shown in Fig. \ref{fig:ProbState}. The red color indicates the critical set, where more than one vehicle should never reside, due to safety reasons. The yellow color shows the enlarged set, which will be discussed later, in Section \ref{sec:extended_cost}. The light blue color indicates the start and end of the control region. The centralized system controls only vehicles in this region. The position, where vehicle $k$ enters respectively exits the critical set, is called $L_k$ respectively $H_k$. The order in which the vehicles cross the intersection is called crossing sequence and the matrix which contains all the possible crossing sequences is called permutation matrix  $\Omega$.

The requirement to allow only one car in the critical set is
unnecessary conservative. For example, two vehicles traveling in
opposite directions could obviously pass the crossing at the same time. However, this
algorithm does not permit it, a relaxation would be needed to allow
this, but this is not done in this contribution.

\begin{figure}
    \centering
    \includegraphics[width=0.9\columnwidth]{czone.pdf}
    \caption{Illustration of an intersection showing the critical set (red), the enlarged set (yellow) and the control region (light blue).}
    \label{fig:ProbState}
\end{figure}

\subsection{Convex problem statement}
To formulate the optimization problem in a convex form, the problem is formulated in space coordinates, rather than time, according to \cite{nikolce}. With the spatial coordinate $p$, the linear state space model
\begin{align}\label{statesp}
\begin{split}
\kappa_i'(p)&=\underbrace{\begin{pmatrix}
0& 1\\
0& 0
\end{pmatrix}}_{{A}}\kappa_i(p) + \underbrace{\begin{pmatrix}
0\\
1\end{pmatrix}}_Bu_i(p)
\end{split}
\end{align}
is used to model each vehicle $i$, where $\kappa_i=\begin{pmatrix}t_i(p)& z_i(p)\end{pmatrix}^T$ is the state vector and $\kappa_i'=d\kappa/dp$ is the derivative with respect to the spatial distance $p$. The slowness of the system is indicated by the \emph{lethargy} \mbox{$z_i(p)=1/v_i(p)$}, where $v_i(p)$ is the vehicle velocity. The time needed to reach position $p$ is $t_i(p)$. Input $u_i(p)=z_i'(p)$ is the spatial derivative of $z_i(p)$.

\subsubsection{Cost function}
The cumulative cost function is the sum of cost functions for each vehicle $i$
\begin{align}
\min_{u_i(p)} \sum_{i=1}^{N_v}
J_i(\kappa_i(p), u_i(p), u_i'(p), \kappa_i(p_{if})), \label{costspace}
\end{align}
where $p_{if}$ is the final position after leaving the intersection. The cost function for each vehicle $i$
\begin{equation}\label{eq:costfnc}
J_i = J_{i1}+J_{i2}+J_{i3}
\end{equation}
consists of three quadratic convex functions. The first term
\begin{subequations}
\begin{equation}
J_{i1} = w_{i1}\bar{v}_{ir}^3 \int_0^{p_{if}}\left(z_i(p)-\frac{1}{v_{ir}(p)}\right)^2 dp
\label{cost1}
\end{equation}
penalizes the deviation from the reference velocity, where $w_{ij}$ [$j=1$ in \eqref{cost1}] are weighting factors. The mean of the reference velocity $v_{ir}(p)$ for each car $i$ is $\bar{v}_{ir}$. The terms $J_{i2}, J_{i3}$ with
\begin{align}
J_{i2} = w_{i2}\bar{v}^5_{ir}
\int_0^{p_{if}}u^2_i(p) dp, \\
J_{i3} = w_{i3}\bar{v}_{ir}^7\int_0^{p_{if}}u_i'^2(p) dp
\end{align}
\end{subequations}
penalize high longitudinal acceleration and jerk to guarantee a comfortable drive and limited actuator usage. The unconventionally appearance of $J_{i2}$ and $J_{i3}$ with powers of the mean velocity is due to that the problem is described in space coordinates. In \cite{nikolce}, it is shown how these are obtained by direct translation of quadratic penalties from time to space domain.

\subsubsection{Constraints}
In addition to the equality constraint (\ref{statesp}), the problem includes inequality constraints on the states $\kappa_i$ and the input $u_i$ as well as initial and final state constraints
\begin{subequations}\label{eq:constraints}
\begin{align}
\kappa_i'(p) &= A\kappa_i(p) + Bu_i(p)\label{eq:spm}\\
\kappa_i(p) &\in [\kappa_{imin}(p), \kappa_{imax}(p)]\label{eq:vlim}\\
%ignore u constraint first????
u_i(p) &\in [u_{imin}(p, z_i(p)), u_{imax}(p, z_i(p))]\label{eq:ulim}\\
\kappa_{i}(0)&=\kappa_{i0} = \begin{pmatrix}0& 1/v_{i0}\end{pmatrix}^T\\
\kappa_{i}(p_{if})&=\kappa_{if} = \begin{pmatrix}\mathrm{free}& 1/v_{if} \end{pmatrix}^T\label{eq:free},
\end{align}
where the limits \eqref{eq:ulim} are linear functions of $z_i$ and represent a linearized inner approximation of corresponding constant acceleration limits in the time domain formulation \cite{nikolce}. To avoid collisions, a final constraint is needed, which guarantees that a vehicle can enter a certain critical set at the center of the intersection, only when the previous vehicle has left the critical set, i.e.
\begin{align}
\begin{split}
t_k(H_k) \leq t_l(L_l),\; k&=\Omega_{m,n},\; l=\Omega_{m,n+1}\label{eq:col},\\
n&=1,\dots, N_v-1,
\end{split}
\end{align}
\end{subequations}
where $k$ and $l$ are indices of consecutive vehicles in a given crossing sequence $m$ of the permutation matrix $\Omega$, which contains all possible crossing sequences. Position $H_k$ is the point where vehicle $k$ exits the critical set and $L_l$ is the entry point for vehicle $l$.
For a given crossing sequence, the optimization problem is a convex quadratic program (QP).

More detailed explanations about the convex modeling of the problem can be found in \cite{nikolce}.
\section{MPC Design} \label{sec:MPC}
This section presents the optimization problem in a discrete space coordinate, proposes and extended cost function and rewrites the problem as a standard QP suitable for MPC implementation.
\subsection{Discrete state space model}
In order to implement the controller in Matlab, a discrete version of the model \eqref{statesp} with a sampling interval $d_s$ is derived with Forward Euler approximation. The result is the following discrete state space representation
\begin{align}
\label{eq:model}
\begin{split}
\kappa_i(p+1) &= A_d \kappa_i(p) + B_d u_i(p),
\end{split}
\end{align}
with the discrete matrices expressed as
\begin{align}
\label{eq:model2}
\begin{split}
    A_d &= I_2 + d_sA = \begin{pmatrix}
        1&d_s\\
        0&1
    \end{pmatrix},\\
B_d &= d_sB = \begin{pmatrix}
    0\\
    d_s
\end{pmatrix}.
\end{split}
\end{align}
In order to guarantee stability of the discretized state space representation, the discretization step must fulfill the criterion
$ |I_2 + d_s A| \leq 1$.
%\begin{align}
%    \label{eq:discstab}
%    \begin{split}
%        |I_2 + d_s A| \leq 1.
%    \end{split}
%\end{align}
Since the eigenvalues of the discrete state space representation $\lambda_{1,2}=1$ are mapped on the border of the unit circle, stability is guaranteed.
%\begin{figure}[h!]
%    \centering
%    \includegraphics[width=0.6\columnwidth]{Eigenvalues.eps}
%    \caption{The eigenvalues of the discretized model are in the gray area and hence is the discretization stable for $d_s = 4$.}
%    \label{fig:Eig}
%\end{figure}


%where $\kappa_i(p) = \begin{pmatrix}
%t_i(p) \\
%z_i(p)
%\end{pmatrix}$ and $u = z'_i$ for each vehicle %$i$ respectively.
\subsection{Extended cost function to impose time gap} \label{sec:extended_cost}
The constraint \eqref{eq:col} prevents the vehicles to collide, but it also allows several vehicles to be on the borders, or very close to the borders of the opposite ends of the critical set [when constraint \eqref{eq:col} is active]. This can lead to an infeasible solution in the next MPC update, in the case when noise and model uncertainty initialize the problem with a \emph{slight} violation of \eqref{eq:col}. Hence, constraint \eqref{eq:col} is modified so that there is some margin between the vehicles. This is done by introducing a slack variable $s_j$ for each consecutive vehicle pair inside the control region. The variable $s_j$ expresses the time difference between the first vehicle leaving the intersection and the second vehicle entering the intersection. By defining $\Delta t$ as the desired time difference, the cost function \eqref{costspace} can be extended to
\begin{subequations}\label{slackall}
\begin{align}\label{eq:smin}
\min_{u_i, s_j} \sum_{i=1}^{N_v}J_i(\cdot) + \sum_{j=1}^{N_v-1}  &w_{j}\max (0,\Delta t -  s_j)^2
\end{align}
and the constraint \eqref{eq:col} can be replaced by
\begin{align}
\label{eq:saeq}
& s_j = t_l(L_l) - t_k(H_k), \quad s_j \geq 0.
\end{align}
\end{subequations}
The maximization in \eqref{eq:smin} is a convex function of $s_j$ and $\Delta t$, where $t_l(L_l)-t_k(H_k) < \Delta t$. Vehicle pairs in which the vehicles are far apart are not forced to have a predefined time difference in the crossing. The extended cost function \eqref{eq:smin} together with constraint \eqref{eq:saeq} effectively introduces an additional enlarged region, which is illustrated in Fig.~\ref{fig:ProbState}. In comparison to the critical set, multiple vehicles may reside within the enlarged region, as long as they are outside the critical set.

Further, the min/max function in \eqref{eq:smin} can be written without the max term as
\begin{subequations}\label{qdef}
\begin{align}\label{eq:qmin}
\min_{s_j}\;  &\sum_{j=1}  w_{j} q_j^2\\
\text{subject to: } & q_j \geq \Delta t - s_j, \quad q_j \geq 0,
\end{align}
\end{subequations}
where $q_j$ are additional optimization variables.
\subsection{Transformation to a standard QP}
In this section, the problem is transformed into the standard QP form
\begin{subequations} \label{stform}
\begin{align}\label{eq:quad}
\min_{x}\; &\frac{1}{2}x^THx+f^Tx\\
\text{subject to: }
&A_{eq}x =b_{eq}\label{eq:aeq}\\
&A_{in}x \leq b_{in},\label{eq:ain}
\end{align}
\end{subequations}
where $x$ is the vector of optimization variables, $H$ the Hessian matrix and $f$ the remaining linear terms in the objective. The constraints are also transformed to fit the formulation in \eqref{eq:aeq}-\eqref{eq:ain}.
\subsubsection{Cost function}
The cost function \eqref{eq:costfnc} is transformed into a quadratic form for the MPC by writing the vector $x=\begin{pmatrix}x_1&\dots&x_{N_v}  \end{pmatrix}^T$ in \eqref{eq:quad} as
\begin{equation}
x_i=%\begin{pmatrix}
(K_i \;\; U_i\;\; U_i' \;\; S_j \;\; Q_j)^T
%\end{pmatrix},
\end{equation}
where $K_i=[\kappa_i(1),\ldots,\kappa_i(N)]^T$, $U_i=[u_i(0),\ldots,u_i(N-1)]^T$, $U'_i=[u'_i(0),\ldots,u'_i(N-1)]^T$, $S_j=[s_j(1),\ldots,s_j(N)]^T$, $Q_j=[q_j(1),\ldots,q_j(N)]^T$ for each vehicle $i$ and vehicle pair $j$ in the control region.
The vector $x_i$ involves the states, the control input, the derivative of the control input and the slack variable. The prediction and control horizon are both equal to N. The Hessian matrix $H_i$ for each vehicle $i$ results in
\begin{equation}\label{eq:hessian}
H_i = 2
\begin{pmatrix}
    Q_{i1} & 0 & 0 & 0 & 0 \\
    0 & Q_{i2} & 0 & 0 & 0 \\
    0 & 0 & Q_{i3} & 0 & 0 \\
    0 & 0 & 0 & 0 & 0  \\
    0 & 0 & 0 & 0 & Q_{i4}
\end{pmatrix}.
\end{equation}
The matrices $Q_{i1}, Q_{i2}$, $Q_{i3}$ and the scalar $Q_{i4}$ are equal to
\begin{subequations}
\begin{align}
Q_{i1} &= w_{i1}\bar{v}_{ir}^3 C^TC I_N, \\
Q_{i2} &=  w_{i2}\bar{v}_{ir}^5I_N ,\\
Q_{i3} &= w_{i3}\bar{v}_{ir}^7I_N, \\
Q_{i4} &= w_j,
\end{align}
\end{subequations}
where $I_N$ is the identity matrix with $N$ rows and $C=[0 \;\; 1]$.
The $f_i$ vector containing the remaining non-quadratic terms for each vehicle $i$ is
%\begin{equation}
%f_i^T = -2w_{i1}\bar{v}_{ir}^3\frac{1}{v_{ir}(p)}C
%\begin{pmatrix}
%1 & \hdots & 1 & 0 & \hdots & 0
%\end{pmatrix}\label{eq:fvec}.
%\end{equation}
%\red{(Please check this equation. Is there a product between matrix C and another matrix which also %has one row?)}
\begin{align}
f_i^T =-2w_{i1}\bar{v}_{ir}^3\frac{1}{v_{ir}(p)} \begin{pmatrix} C & \hdots & C & 0 &\hdots & 0 \end{pmatrix}.
\end{align}
%missing: definitions of w, v_ir etc.
\subsubsection{Constraints}
%The state constraint of the model in \eqref{eq:spm} can be written in the new equality constraint formulation \eqref{eq:aeq} as
The state constraint of the model described in \eqref{eq:spm} has to be reformulated in a matrix form as shown in \eqref{eq:aeq} with the discrete model described in \eqref{eq:model2}. Furthermore, the constraints \eqref{eq:vlim}-\eqref{eq:ulim} limiting the state variables and the acceleration as well as the collision avoidance constraint \eqref{eq:col} can be written into new inequality constraints \eqref{eq:ain}. The two constraints \eqref{eq:vlim}-\eqref{eq:ulim} have to be split up into two constraints in order to be implemented in a matrix form.

In order to control $N_v$ vehicles, the cost function \eqref{eq:quad} needs to be extended. The new vector $x$ and Hessian matrix for $N_v$ cars are then according to \eqref{eq:quad}
\begin{align}
x &=\begin{pmatrix}
x_{1:N_v}^T
\end{pmatrix}^T,\label{xvec}\\
H &= \text{diag}\begin{pmatrix}H_{1:N_v}\end{pmatrix},
\end{align}
and the vector $f$ is changed to
\begin{equation}
f^T =
\begin{pmatrix}
f^T_{1:N_v}
\end{pmatrix}.
\end{equation}

Analogously, the constraints also change in the same manner. Using the vector $x$ \eqref{xvec}, the equality and inequality constraints for all $N_v$ vehicles can be written as
\begin{align}
A_{eq}^T&=
\begin{pmatrix}
    A_{eq,1:N_v}^T
    \end{pmatrix},\\
    b_{eq}^T&=\begin{pmatrix}
    b_{eq,1:N_v}^T
    \end{pmatrix}, \\
A_{in}^T&=
\begin{pmatrix}
    A_{in,1:N_v}^T
    \end{pmatrix},\\
    b_{in}^T&=\begin{pmatrix}
    b_{in,1:N_v}^T
    \end{pmatrix}.
\end{align}
\subsection{Control area and optimization horizon}
Whether a vehicle is included in the MPC computation depends on its distance to the intersection. The control area of the centralized controller is defined for a certain surrounding of the intersection. The vehicle speed at the moment of entering the control area is chosen as a reference. The control area is re-scanned in every time step searching for new arriving or leaving cars. The controller re-optimizes in every time step and takes into account only the vehicles in the control area. %The re-optimization is needed because the vehicles do not follow exactly the desired acceleration computed by the controller due to the simplified point mass model for the vehicle dynamics in the controller.\\ \indent
%Another important point is that the acceleration limits in space domain are convexified in \cite{nikolce} by linearizing $z^3_i(p)$ around the reference speed. Re-linearizing around the actual optimal velocity trajectory, as done in \eqref{ineq}, decreases the linearization error. This is another reason for the re-optimization.\\\\ \indent

Since there is no point in controlling the vehicles after they have passed the control area, the optimization horizon $N_i$ for each vehicle $i = 1,\ldots,N_v$, is not moving along the vehicles as they advance. Instead the horizon is shrinking as the cars are progressing through the control area. Thus, the computation load of the MPC algorithm is decreasing as controlled vehicles are approaching the end of the intersection and it is increasing as new vehicles enter the intersection.
\section{Simulation} \label{sec:simulation}
\begin{figure*}[]
    \centering
    \includegraphics[width=1.8\columnwidth]{CarMaker_Implement2.png}
    \caption{Implementation of the MPC in Simulink combined with CarMaker's Simulink environment. Green color indicates CarMaker's environment and orange color indicates signals taken from CarMaker. The MPC is added in between the two green boxes, where signals, e.g brake and gas are 'hijacked' from CarMaker and used in the MPC algorithm. The output of the MPC with the manipulated signals are afterward reconnected to CarMaker.}
    \label{fig:CM_Implement}
\end{figure*}
In this section the MPC is applied to an advanced vehicle model, with the focus on connecting the MPC developed in Matlab/Simulink to a traffic model and an advanced vehicle model developed in CarMaker.

%For the simulation, a combination of Matlab/Simulink and CarMaker is used.
The MPC is implemented in Simulink as a Matlab Function block, see Fig. \ref{fig:CM_Implement}. The simulation tool IPG CarMaker provides a detailed vehicle model and serves as a simulation environment to design a traffic model, containing an intersection and traffic flow. %The detailed model is used in simulation to test if collisions are avoided. It is also possible in CarMaker to change the type or only some parameters of a car.
Furthermore, CarMaker provides a video animation by the plug in program IPG Movie for visualizing the simulation results. This is used as an additional tool for validation of collision avoidance and representation of the simulation results.

\subsection{Restrictions of CarMaker 5.0.2}
\begin{comment}

\subsubsection{CarMaker for Simulink}
The simulation speed for running CarMaker in Simulink is very slow, especially with additional models. Even little add-ons to the generic vehicle model can lead huge loss in computational performance \cite{qsguide}. Simulations with the MPC Matlab function block included are therefore very time consuming.

\end{comment}
%\subsubsection{Vehicle models}
In CarMaker 5.0.2, only one host car can be simulated as an advanced
car model. For other cars, only their position can be controlled. This
means that the validation is only done with respect to one (the simulated) car,
the others can be placed exactly where the MPC controller commands
them to be. Nevertheless, these cars have the same dynamics as the
point mass model used for the controller design.
\begin{comment}

\subsubsection{Road model}
A CarMaker road is constructed from start to stop by a list of road segments, each one only connected with the previous and following segment \cite{guide}. Thus, it is difficult to construct an intersection, because it is a multiple choice path. For simplicity, an intersection can be constructed by making a turn and letting the road cross itself (see Fig. \ref{fig:CarM}). This causes a limitation to the movements of the vehicles because the motion of the traffic objects is connected to the definition of the road. Thus, the traffic objects have to pass straight through the intersection. A turn in such intersection is not possible.

\end{comment}
\subsection{Simulation environment design}
A CarMaker road is constructed from start to stop by a list of road segments, each one only connected with the previous and following segment \cite{guide}. In this paper, for simplicity, the intersection is constructed by making a turn and letting the road cross itself (see Fig. \ref{fig:CarM}). This causes a limitation to the movements of the vehicles because the motion of the traffic objects is connected to the definition of the road. Thus, the traffic objects have to pass straight through the intersection. A turn in such intersection is not possible.\\ \indent
After the creation of the intersection, traffic is added to the model. For each vehicle, the host car as well as the traffic objects, the vehicle type, the reference starting point and reference speed are preset. The host car starts with a zero velocity and the road model is designed to allow the host vehicle reach its desired speed before entering the controlled intersection area.
\subsection{Including the MPC into CarMaker}
The CarMaker simulation model in Simulink consists of a chain of individual subsystem blocks. These blocks cannot be removed, but their functionality can be changed by overwriting their input or output signals.\\ \indent
The MPC is included by replacing the driver model in CarMaker so that
it gives the gas and brake signals in the \textit{Vehicle Control}
block in Simulink as seen in Fig. \ref{fig:CM_Implement}, where the
preset desired speed is overwritten by the calculated values from the
MPC algorithm. The gas and brake signals from the driver model are
only used for the vehicle with dynamics. For the other vehicles the calculated control signals overwrite directly the acceleration signal without a conversion to gas and brake signals.
\begin{comment}
In CarMaker for Simulink, it is possible to change the vehicle model itself. The model generic.mdl given by CarMaker provides a basic CarMaker model without any additional control blocks \cite{qsguide}. It is used as a start-up model to connect the simulation environment created in CarMaker with the MPC Matlab Function block in Simulink. The CarMaker simulation model in Simulink consists of a chain of individual subsystem blocks. These blocks can not be removed, but their functionality can by changed by overwriting their input or output signals.\\ \indent
The model generic.mdl contains the following models as subsystems: \textit{Driver/Driving Maneuver}, \textit{Vehicle Control} and \textit{Vehicle}. To include the MPC block, the subsystem \textit{Vehicle Control} is modified.
By hijacking the gas and brake signals in the \textit{Vehicle Control} block in Simulink as seen in Fig. \ref{fig:CM_Implement}, the drivers wish is overwritten by the calculated values from the MPC algorithm. The gas and brake signals from the driver model are only used for the vehicle with dynamics, where the control signal calculated by the MPC for this vehicle is converted to the gas and brake signals. For the other vehicles which are static traffic objects, there is no driver model. Therefore, the calculated control signals for these two vehicles overwrite directly the acceleration signal without a conversion to gas and brake signals.
\end{comment}
\section{Simulation evaluation with three vehicles} \label{sec:casestudy}
In the selected case study, the presented MPC is tested for three cars
approaching an intersection as shown in Fig. \ref{fig:CarM}. Car 1 is
simulated using the advanced model in CarMaker, the other two are
simulated with the same point mass model as in the MPC.
\begin{figure}
    \centering
    \includegraphics[width=0.9\columnwidth]{New_SimPic.png}
    \caption{Created intersection crossing in CarMaker environment where the three cars are approaching the intersection.}
    \label{fig:CarM}
\end{figure}
%% add picture
%%maybe we have to actualize this table in the end
% !!!!!
\begin{table}[ht!]
\renewcommand{\arraystretch}{1.3}
\caption{Problem data of the case study.}
\label{data}
\centering
\begin{tabular}{c|c}
\hline
\bfseries Parameter & \bfseries Values\\
\hline
$\begin{pmatrix}v_{1r}& v_{2r}& v_{3r}\end{pmatrix}$ & $\begin{pmatrix} \unitfrac[47]{km}{h}& \unitfrac[48]{km}{h}&\unitfrac[50]{km}{h}\end{pmatrix}$\\
$\begin{pmatrix}v_{imin}& v_{imax}\end{pmatrix}$ & $\begin{pmatrix} \unitfrac[30]{km}{h}& \unitfrac[90]{km}{h}\end{pmatrix}$\\
$\begin{pmatrix}a_{imin}& a_{imax}\end{pmatrix}$ & $\begin{pmatrix} \unitfrac[-3]{m}{s^2}& \unitfrac[3]{m}{s^2}\end{pmatrix}$\\
$\begin{pmatrix} w_{i1} &w_{i2} &w_{i3} & w_{i4}\end{pmatrix}$&
$\begin{pmatrix} 1  &  1100 & 23 & 10000 \end{pmatrix}$ \\
$\Delta t$ & \unit[0.6]{s}\\
 $d_s$ & \unit[4]{m} \\
\hline
\end{tabular}
\end{table}
In Table \ref{data}, the parameters for the cars $i=1,2,3$ can be
found. The speed and acceleration limits as well as the weights for
the cost function are selected identically for all three vehicles. The
desired crossing sequence is chosen to $1,2,3$. This means, for space reasons, that the search over
possible crossing sequences, one of the motivations to formulate the
problem as an efficient QP, is skipped. The vehicles start with
different initial speed and distances from the intersection. Without a
controller, car $1$ and $2$ would collide in the
intersection\footnote{A video animation showing that vehicles would
  collide if not controlled, is provided at
  \url{https://youtu.be/LKcXflY6Mtw}.}. The MPC takes control over a
vehicle when it has entered the control distance of the intersection,
which is \unit[60]{m}. The critical set, where no collisions are allowed, is
the \unit[15$\cdot$15]{m$^2$} intersection crossing area. The vehicles do not
turn left or right in the intersection, instead they only drive
straight forward. The initial optimization horizon for every car
entering the control area is N=135 steps, with a sampling interval of \unit[1]{m}. \\ \indent
Data gathered from the CarMaker vehicle sensors are shown in the top three plots of Fig. \ref{fig:sim_results}. When vehicle $1$ comes closer to the intersection it can be observed that it starts to accelerate and vehicle $2$ starts to decelerate in order to avoid a collision. The third vehicle slows down to avoid a collision between the second and third vehicle.
%One notable part in these figures are the acceleration of the static %vehicles without dynamics in the middle plot, i.e. vehicle 2 and %vehicle 3. Their acceleration is fluctuating considerably more than %vehicle 1 which is the vehicle with dynamics. One explanation is %that the acceleration of these two static cars is directly fed from %the MPC algorithm, whereas for the first car, it will be converted %to gas and brake signals via a PI controller. Additional tuning on %the jerk penalty of the static cars in the cost function may %decrease the fluctuation.
Furthermore, by looking at the last plot, it is evident that the MPC controller efficiently prohibits collisions between the vehicles\footnote{A video animation showing that the controller has prevented collision can be found on \url{https://youtu.be/VV36-eJ0tEw}. In the video, it can be observed that the cars drive in a smooth way following the given crossing sequence and there is never more than one car in the intersection.}. An upward-pointing triangle depicts the time where the vehicle is entering the intersection and a downward-pointing triangle shows the time when it is leaving. Since there is no vertical alignment among the triangles, there are no collisions.
%CarMaker provides also a video animation for visualizing the simulation results.
\begin{figure}[ht!]
    \centering
    \includegraphics[width=0.52\textwidth]{New_Result_ds4.eps}
    \caption{Trajectories from the MPC controller. The upper three subplots show velocity, acceleration and position for each vehicle. The very last plot shows the computation time of the quadratic programming solver.}
    \label{fig:sim_results}
\end{figure}

Compared to the solution presented in \cite{nikolce}, the computation time for the convex problem is decreased by using a QP solver instead of the generalized second order cone program (SOCP) solver. It can be seen in the bottom plot of Fig. \ref{fig:sim_results} that in the worst case scenario, the problem can be solved in less than 0.05 seconds\footnote{The Simulation was preformed on a computer with (Intel(R) Core(TM) i7-3520M) processor and 8 GB RAM.}. The figure also shows that the computation time has an increasing trend, up to the MPC update at about the 18th second, when all cars have entered the control area. After this, the computation time has a decreasing trend, since the prediction horizon is shrinking for all the vehicles.

\section{Conclusions} \label{sec:conclusions}
This paper provides a centralized MPC for optimal control of
autonomous vehicles in the control area of an intersection. The
problem is formulated as a convex quadratic program that can be solved
efficiently. The controller is tested for an advanced vehicle model
using the simulation tool CarMaker. The simulation results show
that the test environment works as intended, and the algorithm
successfully avoids collisions in the test example.\\ \indent
Hence, the test environment is ready to be used for more advanced
validation of the MPC algorithm. Sensor  noise can be included, and
the parameters of the test situation can be explored. Also, the
simulation environment can be extended for further validation tests,
the road construction can be improved to allow cars turning in the
crossing, robustness can be explored adding noise to the not simulated
cars etc. These, and further tasks are left for future studies.

%In the MPC design, the vehicle dynamic is modeled as a simplified point mass model. Testing the controller for an advanced vehicle model by combining CarMaker and Matlab/Simulink shows that all constraints are fulfilled, especially the prohibition of collisions.
%The MPC works efficiently for the virtual test drive, but using
%CarMaker as a simulation environment turned out to have some
%limitations. 

%Future studies may focus on testing the algorithm in different
%simulation environments and with real vehicles.

%The simulation tool PreScan combined with Matlab/Simulink could be
%applicable for the validation in a more extended virtual case study. 

%CarMaker provides an advanced vehicle model only for the host car. The other vehicles are described as static objects, which limits the result. Furthermore, due to the immense computation time for simulations, where the simulation environment of CarMaker is combined with the MPC in Matlab/Simulink, it is very costly to test the MPC for the presented simple case study. Thus, testing the virtual test drive with changed parameters like adjusted weights is problematic because of the expenditure of time.
%For a more extended case study, e.g. with more cars in the control area, CarMaker 5.0.2 combined with Matlab/Simulink can therefore be considered as ineffective as a virtual test basis.%\\ \indent
%Though CarMaker may not be the best choice as a simulation tool in order to validate the control algorithm, the program was useful to visualize and validate the controller output in a 3D environment with the plug in program IPG Movie. After a simulation it is possible to view a video animation in several different angles and camera positions and also export the visualization as movies or photos as in Figure \ref{fig:CarM}.\\ \indent
%In this paper, a fixed crossing sequence is used for testing the MPC due to the restrictions in computation time using CarMaker. The optimal crossing sequence could be found by computing the optimal solution for all permutations of crossing sequences and selecting the crossing sequence that minimizes the cost function as described in \cite{nikolce}. For applying that and validating the efficiency of the presented controller in more extended virtual case studies with more cars, desirable all with an advanced vehicle model, another simulation environment needs to be found or the existing code has to be improved regarding computation speed. A simulation environment, that can be combined with Matlab/Simulink and may be more efficient in this case, is the simulation tool PreScan, but further research on this has to be done. Future work may focus on testing other simulation strategies to validate the controller in extended virtual case studies. Another research branch may be the extension of the formulated convex problem focusing on other objectives and constraints, e.g. safety constraints when several vehicles travel on the same path.

%Another subject to investigate further is the need of adding an extra constraint for the collision avoidance. The MPC algorithm uses the current longitudinal position of each vehicle as a index of the distance to the intersection. One drawback and problem occurs when a vehicle is entering the critical set. The index of when the vehicle entered the critical set will then be a negative integer, which can't be used to describe a index. In the algorithm is the collision avoidance constraint hence only activated until the second vehicle enters the critical set. This constraint fulfills the criteria avoid collision in this case study but a more detailed constraint that can handle negative distance to the intersection can be a more generalized solution. For example if a second vehicle $c2$ entered the intersection one meter ago, then the first car $c1$ have to be 1 meter past the critical set.

%Also, by using position as index variable for the control algorithm restrict the step index to be a at least one meter. The actual position in the Simulation environment is not all ways fulfilling this criteria and therefore is the current longitudinal position needed to be rounded to a integer value.


\bibliographystyle{IEEEtran}
\bibliography{database}

\end{document}

